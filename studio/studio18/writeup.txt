1. Donggyu Kim(437008)

2. 
Code :
use std::thread;

fn main() {
    thread::spawn(||{ println!("Hello from a child thread");});
    println!("Hello, world!");
}


Output:
Hello, world!


3.
Output:
Hello, world!
Hello from a child thread

4. 

code:
use std::thread;
use std::env;

fn main() {


    let mut thread_handles = vec![];


    for arg in env::args().skip(1){


    thread_handles.push(
        thread::spawn(move || println!("{}",arg))
        );
    }

    for handle in thread_handles { 
        let _ =  handle.join();
    }
     
}


output: 
this
running
a
test

5.

code:

     let mut thread_handles = vec![];


     for arg in env::args().skip(1){


        thread_handles.push(
            thread::spawn(move || arg)
            );
        }


        for handle in thread_handles { 
            let name =  handle.join().unwrap();
    

            match File::open(name) {
                Ok(file) => {
                    let reader = BufReader::new(file);
                    
                    for line in reader.lines() {
                        match line {
                           
                            Ok(line) =>  if !line.is_empty(){
                                println!("{}", line)
                            },
                            Err(e) => println!("{}", e),
                        }
                    }
                },
                Err(e) => println!("{}", e),
        }
    }
     

output:
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 3
[[package]]
name = "concurrency"
version = "0.1.0"
No such file or directory (os error 2)
[package]
name = "concurrency"
version = "0.1.0"
edition = "2021"
# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
[dependencies]
No such file or directory (os error 2)



6. 
output: 
connection received from 127.0.0.1:51074
Ok(28)


code:
fn main() {

        let adr = "127.0.0.1:7878";
        let listener = TcpListener::bind(adr).unwrap();

        let mut buffer = [0; 128];

        let connection_handle = spawn(move || {
            let (mut stream, addr) = listener.accept().unwrap();
            println!("connection received from {}", addr);
            println!("{:?}", stream.read(&mut buffer));
        });


        let mut stream = TcpStream::connect(adr).unwrap();
        let args: Vec<String> = env::args().collect();

        for arg in args {
            stream.write_all(arg.as_bytes());
        }
       
        stream.shutdown(Shutdown::Both).expect("shutdown call failed");

        connection_handle.join().unwrap();
}


7. 
Because the other thread has not joined yet, because the loop keeps running inside.

8.
I think if you do not provide extra line of connect after setting atomic value to true,
the listener that was running before the atomic variable was set to true in the loop in the listener thread will keep waiting until
there is a new connection...?